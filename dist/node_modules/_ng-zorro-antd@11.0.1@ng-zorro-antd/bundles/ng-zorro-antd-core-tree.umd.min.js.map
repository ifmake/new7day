{"version":3,"sources":["../../components/core/tree/nz-tree-base-node.ts","../../node_modules/tslib/tslib.es6.js","../../components/core/tree/nz-tree-base-util.ts","../../components/core/tree/nz-tree-base.service.ts","../../components/core/tree/nz-tree-service.resolver.ts","../../components/core/tree/nz-tree-base.ts"],"names":["NzTreeNode","option","parent","service","_this","this","_title","level","parentNode","_icon","_children","_isLeaf","_isChecked","_isSelectable","_isDisabled","_isDisableCheckbox","_isExpanded","_isHalfChecked","_isSelected","_isLoading","canHide","isMatched","origin","key","title","icon","isLeaf","checked","disabled","selectable","disableCheckbox","expanded","selected","children","forEach","nodeOptions","s","treeService","isCheckStrictly","push","Object","defineProperty","prototype","value","update","afterValueChange","setSyncChecked","halfChecked","setChecked","conduct","isChecked","isHalfChecked","setExpanded","getParentNode","getChildren","addChildren","childPos","node","refreshLevel","n","c","child","splice","e","map","v","isLoading","clearChildren","remove","filter","setCheckedNodeList","setHalfCheckedNodeList","setExpandedNodeList","setNodeActive","afterRemove","flattenTreeData","rootNodes","getExpandedNodeList","component","markForCheck","create","__values","o","Symbol","iterator","m","i","call","length","next","done","TypeError","__read","r","ar","error","__spread","arguments","concat","isCheckDisabled","isDisabled","isDisableCheckbox","isInArray","needle","haystack","indexOf","getPosition","index","getKey","pos","treeNodeList","expandedKeys","expandedKeySet","Set","flattenList","dig","list","treeNode","mergedKey","isStart","isEnd","flattenNode","data","has","isExpanded","NzTreeBaseService","DRAG_SIDE_RANGE","DRAG_MIN_GAP","isMultiple","flattenNodes$","BehaviorSubject","selectedNodeList","expandedNodeList","checkedNodeList","halfCheckedNodeList","matchedNodeList","initTree","nzNodes","item","getSelectedNode","selectedNode","getSelectedNodeList","conductNodeState","getCheckedNodeList","getHalfCheckedNodeList","getMatchedNodeList","isArrayOfNzTreeNode","every","setSelectedNode","isSelected","setSelectedNodeList","getIndexOfArray","type","resultNodesList","isIgnore_1","findIndex","setMatchedNodeList","refreshCheckState","conductUp","conductDown","some","nodes","loopNode","refreshDragNode","resetNodeLevel","_b","_c","calcDropPosition","event","clientY","_a","target","getBoundingClientRect","top","bottom","height","des","Math","max","dropAndApply","targetNode","dragPos","targetParent","isSelectedRootNode","tIndex","targetIndex","formatEvent","eventName","emitStructure","assign","dragNode","selectedKeys","keys","checkedKeys","matchedKeys","conductCheck","checkStrictly","calc","conductExpandedKeys","conductSelectedKeys","isMulti","expandNodeAllParentBySearch","Injectable","NzTreeHigherOrderServiceToken","InjectionToken","NzTreeBase","nzTreeService","coerceTreeNodes","getTreeNodes","getTreeNodeByKey","getNode","find"],"mappings":"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","sourcesContent":["/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport { NzSafeAny } from 'ng-zorro-antd/core/types';\nimport { NzTreeNodeBaseComponent } from './nz-tree-base.definitions';\nimport { NzTreeBaseService } from './nz-tree-base.service';\n\nexport type NzTreeNodeKey = string | number;\n\nexport interface FlattenNode {\n  parent: FlattenNode | null;\n  children: FlattenNode[];\n  pos: string;\n  data: NzTreeNode;\n  isStart: boolean[];\n  isEnd: boolean[];\n}\n\nexport interface NzTreeNodeOptions {\n  title: string;\n  key: string;\n  icon?: string;\n  isLeaf?: boolean;\n  checked?: boolean;\n  selected?: boolean;\n  selectable?: boolean;\n  disabled?: boolean;\n  disableCheckbox?: boolean;\n  expanded?: boolean;\n  children?: NzTreeNodeOptions[];\n\n  [key: string]: NzSafeAny;\n}\n\nexport class NzTreeNode {\n  private _title: string = '';\n  key!: string;\n  level: number = 0;\n  origin!: NzTreeNodeOptions;\n  // Parent Node\n  parentNode: NzTreeNode | null = null;\n  private _icon: string = '';\n  private _children: NzTreeNode[] = [];\n  private _isLeaf: boolean = false;\n  private _isChecked: boolean = false;\n  private _isSelectable: boolean = false;\n  private _isDisabled: boolean = false;\n  private _isDisableCheckbox: boolean = false;\n  private _isExpanded: boolean = false;\n  private _isHalfChecked: boolean = false;\n  private _isSelected: boolean = false;\n  private _isLoading: boolean = false;\n  canHide: boolean = false;\n  isMatched: boolean = false;\n\n  service: NzTreeBaseService | null = null;\n  component!: NzTreeNodeBaseComponent;\n\n  /** New added in Tree for easy data access */\n  isStart?: boolean[];\n  isEnd?: boolean[];\n\n  get treeService(): NzTreeBaseService | null {\n    return this.service || (this.parentNode && this.parentNode.treeService);\n  }\n\n  /**\n   * Init nzTreeNode\n   * @param option: user's input\n   * @param parent\n   * @param service: base nzTreeService\n   */\n  constructor(option: NzTreeNodeOptions | NzTreeNode, parent: NzTreeNode | null = null, service: NzTreeBaseService | null = null) {\n    if (option instanceof NzTreeNode) {\n      return option;\n    }\n    this.service = service || null;\n    this.origin = option;\n    this.key = option.key;\n    this.parentNode = parent;\n    this._title = option.title || '---';\n    this._icon = option.icon || '';\n    this._isLeaf = option.isLeaf || false;\n    this._children = [];\n    // option params\n    this._isChecked = option.checked || false;\n    this._isSelectable = option.disabled || option.selectable !== false;\n    this._isDisabled = option.disabled || false;\n    this._isDisableCheckbox = option.disableCheckbox || false;\n    this._isExpanded = option.isLeaf ? false : option.expanded || false;\n    this._isHalfChecked = false;\n    this._isSelected = (!option.disabled && option.selected) || false;\n    this._isLoading = false;\n    this.isMatched = false;\n\n    /**\n     * parent's checked status will affect children while initializing\n     */\n    if (parent) {\n      this.level = parent.level + 1;\n    } else {\n      this.level = 0;\n    }\n    if (typeof option.children !== 'undefined' && option.children !== null) {\n      option.children.forEach(nodeOptions => {\n        const s = this.treeService;\n        if (s && !s.isCheckStrictly && option.checked && !option.disabled && !nodeOptions.disabled && !nodeOptions.disableCheckbox) {\n          nodeOptions.checked = option.checked;\n        }\n        this._children.push(new NzTreeNode(nodeOptions, this));\n      });\n    }\n  }\n\n  /**\n   * auto generate\n   * get\n   * set\n   */\n  get title(): string {\n    return this._title;\n  }\n\n  set title(value: string) {\n    this._title = value;\n    this.update();\n  }\n\n  get icon(): string {\n    return this._icon;\n  }\n\n  set icon(value: string) {\n    this._icon = value;\n    this.update();\n  }\n\n  get children(): NzTreeNode[] {\n    return this._children;\n  }\n\n  set children(value: NzTreeNode[]) {\n    this._children = value;\n    this.update();\n  }\n\n  get isLeaf(): boolean {\n    return this._isLeaf;\n  }\n\n  set isLeaf(value: boolean) {\n    this._isLeaf = value;\n    this.update();\n  }\n\n  get isChecked(): boolean {\n    return this._isChecked;\n  }\n\n  set isChecked(value: boolean) {\n    this._isChecked = value;\n    this.origin.checked = value;\n    this.afterValueChange('isChecked');\n  }\n\n  get isHalfChecked(): boolean {\n    return this._isHalfChecked;\n  }\n\n  set isHalfChecked(value: boolean) {\n    this._isHalfChecked = value;\n    this.afterValueChange('isHalfChecked');\n  }\n\n  get isSelectable(): boolean {\n    return this._isSelectable;\n  }\n\n  set isSelectable(value: boolean) {\n    this._isSelectable = value;\n    this.update();\n  }\n\n  get isDisabled(): boolean {\n    return this._isDisabled;\n  }\n\n  set isDisabled(value: boolean) {\n    this._isDisabled = value;\n    this.update();\n  }\n\n  get isDisableCheckbox(): boolean {\n    return this._isDisableCheckbox;\n  }\n\n  set isDisableCheckbox(value: boolean) {\n    this._isDisableCheckbox = value;\n    this.update();\n  }\n\n  get isExpanded(): boolean {\n    return this._isExpanded;\n  }\n\n  set isExpanded(value: boolean) {\n    this._isExpanded = value;\n    this.origin.expanded = value;\n    this.afterValueChange('isExpanded');\n    this.afterValueChange('reRender');\n  }\n\n  get isSelected(): boolean {\n    return this._isSelected;\n  }\n\n  set isSelected(value: boolean) {\n    this._isSelected = value;\n    this.origin.selected = value;\n    this.afterValueChange('isSelected');\n  }\n\n  get isLoading(): boolean {\n    return this._isLoading;\n  }\n\n  set isLoading(value: boolean) {\n    this._isLoading = value;\n    this.update();\n  }\n\n  public setSyncChecked(checked: boolean = false, halfChecked: boolean = false): void {\n    this.setChecked(checked, halfChecked);\n    if (this.treeService && !this.treeService.isCheckStrictly) {\n      this.treeService.conduct(this);\n    }\n  }\n\n  public setChecked(checked: boolean = false, halfChecked: boolean = false): void {\n    this.origin.checked = checked;\n    this.isChecked = checked;\n    this.isHalfChecked = halfChecked;\n  }\n\n  public setExpanded(value: boolean): void {\n    this._isExpanded = value;\n    this.origin.expanded = value;\n    this.afterValueChange('isExpanded');\n  }\n\n  public getParentNode(): NzTreeNode | null {\n    return this.parentNode;\n  }\n\n  public getChildren(): NzTreeNode[] {\n    return this.children;\n  }\n\n  /**\n   * Support appending child nodes by position. Leaf node cannot be appended.\n   */\n  public addChildren(children: NzSafeAny[], childPos: number = -1): void {\n    if (!this.isLeaf) {\n      children.forEach(node => {\n        const refreshLevel = (n: NzTreeNode) => {\n          n.getChildren().forEach(c => {\n            c.level = c.getParentNode()!.level + 1;\n            // flush origin\n            c.origin.level = c.level;\n            refreshLevel(c);\n          });\n        };\n        let child = node;\n        if (child instanceof NzTreeNode) {\n          child.parentNode = this;\n        } else {\n          child = new NzTreeNode(node, this);\n        }\n        child.level = this.level + 1;\n        child.origin.level = child.level;\n        refreshLevel(child);\n        try {\n          childPos === -1 ? this.children.push(child) : this.children.splice(childPos, 0, child);\n          // flush origin\n        } catch (e) {}\n      });\n      this.origin.children = this.getChildren().map(v => v.origin);\n      // remove loading state\n      this.isLoading = false;\n    }\n    this.afterValueChange('addChildren');\n    this.afterValueChange('reRender');\n  }\n\n  public clearChildren(): void {\n    // refresh checked state\n    this.afterValueChange('clearChildren');\n    this.children = [];\n    this.origin.children = [];\n    this.afterValueChange('reRender');\n  }\n\n  public remove(): void {\n    const parentNode = this.getParentNode();\n    if (parentNode) {\n      parentNode.children = parentNode.getChildren().filter(v => v.key !== this.key);\n      parentNode.origin.children = parentNode.origin.children!.filter(v => v.key !== this.key);\n      this.afterValueChange('remove');\n      this.afterValueChange('reRender');\n    }\n  }\n\n  public afterValueChange(key: string): void {\n    if (this.treeService) {\n      switch (key) {\n        case 'isChecked':\n          this.treeService.setCheckedNodeList(this);\n          break;\n        case 'isHalfChecked':\n          this.treeService.setHalfCheckedNodeList(this);\n          break;\n        case 'isExpanded':\n          this.treeService.setExpandedNodeList(this);\n          break;\n        case 'isSelected':\n          this.treeService.setNodeActive(this);\n          break;\n        case 'clearChildren':\n          this.treeService.afterRemove(this.getChildren());\n          break;\n        case 'remove':\n          this.treeService.afterRemove([this]);\n          break;\n        case 'reRender':\n          this.treeService.flattenTreeData(\n            this.treeService.rootNodes,\n            this.treeService.getExpandedNodeList().map(v => v.key!)\n          );\n          break;\n      }\n    }\n    this.update();\n  }\n\n  public update(): void {\n    if (this.component) {\n      this.component.markForCheck();\n    }\n  }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport { NzSafeAny } from 'ng-zorro-antd/core/types';\nimport { FlattenNode, NzTreeNode, NzTreeNodeKey } from './nz-tree-base-node';\n\nexport function isCheckDisabled(node: NzTreeNode): boolean {\n  const { isDisabled, isDisableCheckbox } = node;\n  return !!(isDisabled || isDisableCheckbox);\n}\n\nexport function isInArray(needle: NzSafeAny, haystack: NzSafeAny[]): boolean {\n  return haystack.length > 0 && haystack.indexOf(needle) > -1;\n}\n\nexport function getPosition(level: string | number, index: number): string {\n  return `${level}-${index}`;\n}\n\nexport function getKey(key: NzTreeNodeKey, pos: string): NzTreeNodeKey {\n  if (key !== null && key !== undefined) {\n    return key;\n  }\n  return pos;\n}\n\n/**\n * Flat nest tree data into flatten list. This is used for virtual list render.\n * @param treeNodeList Origin data node list\n * @param expandedKeys\n * need expanded keys, provides `true` means all expanded (used in `rc-tree-select`).\n */\nexport function flattenTreeData(treeNodeList: NzTreeNode[] = [], expandedKeys: NzTreeNodeKey[] | true = []): FlattenNode[] {\n  const expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);\n  const flattenList: FlattenNode[] = [];\n\n  function dig(list: NzTreeNode[], parent: FlattenNode | null = null): FlattenNode[] {\n    return list.map((treeNode, index) => {\n      const pos: string = getPosition(parent ? parent.pos : '0', index);\n      const mergedKey = getKey(treeNode.key, pos);\n      treeNode.isStart = [...(parent ? parent.isStart : []), index === 0];\n      treeNode.isEnd = [...(parent ? parent.isEnd : []), index === list.length - 1];\n      // Add FlattenDataNode into list\n      // TODO: only need data here.\n      const flattenNode: FlattenNode = {\n        parent,\n        pos,\n        children: [],\n        data: treeNode,\n        isStart: [...(parent ? parent.isStart : []), index === 0],\n        isEnd: [...(parent ? parent.isEnd : []), index === list.length - 1]\n      };\n\n      flattenList.push(flattenNode);\n\n      // Loop treeNode children\n      if (expandedKeys === true || expandedKeySet.has(mergedKey) || treeNode.isExpanded) {\n        flattenNode.children = dig(treeNode.children || [], flattenNode);\n      } else {\n        flattenNode.children = [];\n      }\n\n      return flattenNode;\n    });\n  }\n\n  dig(treeNodeList);\n  return flattenList;\n}\n","/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport { Injectable } from '@angular/core';\n\nimport { NzSafeAny } from 'ng-zorro-antd/core/types';\nimport { BehaviorSubject } from 'rxjs';\nimport { NzTreeNode, NzTreeNodeKey } from './nz-tree-base-node';\nimport { flattenTreeData, isCheckDisabled, isInArray } from './nz-tree-base-util';\nimport { NzFormatEmitEvent } from './nz-tree-base.definitions';\n\n@Injectable()\nexport class NzTreeBaseService {\n  DRAG_SIDE_RANGE = 0.25;\n  DRAG_MIN_GAP = 2;\n\n  isCheckStrictly: boolean = false;\n  isMultiple: boolean = false;\n  selectedNode!: NzTreeNode;\n  rootNodes: NzTreeNode[] = [];\n  flattenNodes$ = new BehaviorSubject<NzTreeNode[]>([]);\n  selectedNodeList: NzTreeNode[] = [];\n  expandedNodeList: NzTreeNode[] = [];\n  checkedNodeList: NzTreeNode[] = [];\n  halfCheckedNodeList: NzTreeNode[] = [];\n  matchedNodeList: NzTreeNode[] = [];\n\n  /**\n   * reset tree nodes will clear default node list\n   */\n  initTree(nzNodes: NzTreeNode[]): void {\n    this.rootNodes = nzNodes;\n    this.expandedNodeList = [];\n    this.selectedNodeList = [];\n    this.halfCheckedNodeList = [];\n    this.checkedNodeList = [];\n    this.matchedNodeList = [];\n  }\n\n  flattenTreeData(nzNodes: NzTreeNode[], expandedKeys: NzTreeNodeKey[] | true = []): void {\n    this.flattenNodes$.next(flattenTreeData(nzNodes, expandedKeys).map(item => item.data));\n  }\n\n  getSelectedNode(): NzTreeNode | null {\n    return this.selectedNode;\n  }\n\n  /**\n   * get some list\n   */\n  getSelectedNodeList(): NzTreeNode[] {\n    return this.conductNodeState('select');\n  }\n\n  /**\n   * return checked nodes\n   */\n  getCheckedNodeList(): NzTreeNode[] {\n    return this.conductNodeState('check');\n  }\n\n  getHalfCheckedNodeList(): NzTreeNode[] {\n    return this.conductNodeState('halfCheck');\n  }\n\n  /**\n   * return expanded nodes\n   */\n  getExpandedNodeList(): NzTreeNode[] {\n    return this.conductNodeState('expand');\n  }\n\n  /**\n   * return search matched nodes\n   */\n  getMatchedNodeList(): NzTreeNode[] {\n    return this.conductNodeState('match');\n  }\n\n  isArrayOfNzTreeNode(value: NzSafeAny[]): boolean {\n    return value.every(item => item instanceof NzTreeNode);\n  }\n\n  /**\n   * set drag node\n   */\n  setSelectedNode(node: NzTreeNode): void {\n    this.selectedNode = node;\n  }\n\n  /**\n   * set node selected status\n   */\n  setNodeActive(node: NzTreeNode): void {\n    if (!this.isMultiple && node.isSelected) {\n      this.selectedNodeList.forEach(n => {\n        if (node.key !== n.key) {\n          // reset other nodes\n          n.isSelected = false;\n        }\n      });\n      // single mode: remove pre node\n      this.selectedNodeList = [];\n    }\n    this.setSelectedNodeList(node, this.isMultiple);\n  }\n\n  /**\n   * add or remove node to selectedNodeList\n   */\n  setSelectedNodeList(node: NzTreeNode, isMultiple: boolean = false): void {\n    const index = this.getIndexOfArray(this.selectedNodeList, node.key);\n    if (isMultiple) {\n      if (node.isSelected && index === -1) {\n        this.selectedNodeList.push(node);\n      }\n    } else {\n      if (node.isSelected && index === -1) {\n        this.selectedNodeList = [node];\n      }\n    }\n    if (!node.isSelected) {\n      this.selectedNodeList = this.selectedNodeList.filter(n => n.key !== node.key);\n    }\n  }\n\n  /**\n   * merge checked nodes\n   */\n  setHalfCheckedNodeList(node: NzTreeNode): void {\n    const index = this.getIndexOfArray(this.halfCheckedNodeList, node.key);\n    if (node.isHalfChecked && index === -1) {\n      this.halfCheckedNodeList.push(node);\n    } else if (!node.isHalfChecked && index > -1) {\n      this.halfCheckedNodeList = this.halfCheckedNodeList.filter(n => node.key !== n.key);\n    }\n  }\n\n  setCheckedNodeList(node: NzTreeNode): void {\n    const index = this.getIndexOfArray(this.checkedNodeList, node.key);\n    if (node.isChecked && index === -1) {\n      this.checkedNodeList.push(node);\n    } else if (!node.isChecked && index > -1) {\n      this.checkedNodeList = this.checkedNodeList.filter(n => node.key !== n.key);\n    }\n  }\n\n  /**\n   * conduct checked/selected/expanded keys\n   */\n  conductNodeState(type: string = 'check'): NzTreeNode[] {\n    let resultNodesList: NzTreeNode[] = [];\n    switch (type) {\n      case 'select':\n        resultNodesList = this.selectedNodeList;\n        break;\n      case 'expand':\n        resultNodesList = this.expandedNodeList;\n        break;\n      case 'match':\n        resultNodesList = this.matchedNodeList;\n        break;\n      case 'check':\n        resultNodesList = this.checkedNodeList;\n        const isIgnore = (node: NzTreeNode): boolean => {\n          const parentNode = node.getParentNode();\n          if (parentNode) {\n            if (this.checkedNodeList.findIndex(n => n.key === parentNode.key) > -1) {\n              return true;\n            } else {\n              return isIgnore(parentNode);\n            }\n          }\n          return false;\n        };\n        // merge checked\n        if (!this.isCheckStrictly) {\n          resultNodesList = this.checkedNodeList.filter(n => !isIgnore(n));\n        }\n        break;\n      case 'halfCheck':\n        if (!this.isCheckStrictly) {\n          resultNodesList = this.halfCheckedNodeList;\n        }\n        break;\n    }\n    return resultNodesList;\n  }\n\n  /**\n   * set expanded nodes\n   */\n  setExpandedNodeList(node: NzTreeNode): void {\n    if (node.isLeaf) {\n      return;\n    }\n    const index = this.getIndexOfArray(this.expandedNodeList, node.key);\n    if (node.isExpanded && index === -1) {\n      this.expandedNodeList.push(node);\n    } else if (!node.isExpanded && index > -1) {\n      this.expandedNodeList.splice(index, 1);\n    }\n  }\n\n  setMatchedNodeList(node: NzTreeNode): void {\n    const index = this.getIndexOfArray(this.matchedNodeList, node.key);\n    if (node.isMatched && index === -1) {\n      this.matchedNodeList.push(node);\n    } else if (!node.isMatched && index > -1) {\n      this.matchedNodeList.splice(index, 1);\n    }\n  }\n\n  /**\n   * check state\n   * @param isCheckStrictly\n   */\n  refreshCheckState(isCheckStrictly: boolean = false): void {\n    if (isCheckStrictly) {\n      return;\n    }\n    this.checkedNodeList.forEach(node => {\n      this.conduct(node, isCheckStrictly);\n    });\n  }\n\n  // reset other node checked state based current node\n  conduct(node: NzTreeNode, isCheckStrictly: boolean = false): void {\n    const isChecked = node.isChecked;\n    if (node && !isCheckStrictly) {\n      this.conductUp(node);\n      this.conductDown(node, isChecked);\n    }\n  }\n\n  /**\n   * 1、children half checked\n   * 2、children all checked, parent checked\n   * 3、no children checked\n   */\n  conductUp(node: NzTreeNode): void {\n    const parentNode = node.getParentNode();\n    if (parentNode) {\n      if (!isCheckDisabled(parentNode)) {\n        if (parentNode.children.every(child => isCheckDisabled(child) || (!child.isHalfChecked && child.isChecked))) {\n          parentNode.isChecked = true;\n          parentNode.isHalfChecked = false;\n        } else if (parentNode.children.some(child => child.isHalfChecked || child.isChecked)) {\n          parentNode.isChecked = false;\n          parentNode.isHalfChecked = true;\n        } else {\n          parentNode.isChecked = false;\n          parentNode.isHalfChecked = false;\n        }\n      }\n      this.setCheckedNodeList(parentNode);\n      this.setHalfCheckedNodeList(parentNode);\n      this.conductUp(parentNode);\n    }\n  }\n\n  /**\n   * reset child check state\n   */\n  conductDown(node: NzTreeNode, value: boolean): void {\n    if (!isCheckDisabled(node)) {\n      node.isChecked = value;\n      node.isHalfChecked = false;\n      this.setCheckedNodeList(node);\n      this.setHalfCheckedNodeList(node);\n      node.children.forEach(n => {\n        this.conductDown(n, value);\n      });\n    }\n  }\n\n  /**\n   * flush after delete node\n   */\n  afterRemove(nodes: NzTreeNode[]): void {\n    // to reset selectedNodeList & expandedNodeList\n    const loopNode = (node: NzTreeNode) => {\n      // remove selected node\n      this.selectedNodeList = this.selectedNodeList.filter(n => n.key !== node.key);\n      // remove expanded node\n      this.expandedNodeList = this.expandedNodeList.filter(n => n.key !== node.key);\n      // remove checked node\n      this.checkedNodeList = this.checkedNodeList.filter(n => n.key !== node.key);\n      if (node.children) {\n        node.children.forEach(child => {\n          loopNode(child);\n        });\n      }\n    };\n    nodes.forEach(n => {\n      loopNode(n);\n    });\n    this.refreshCheckState(this.isCheckStrictly);\n  }\n\n  /**\n   * drag event\n   */\n  refreshDragNode(node: NzTreeNode): void {\n    if (node.children.length === 0) {\n      // until root\n      this.conductUp(node);\n    } else {\n      node.children.forEach(child => {\n        this.refreshDragNode(child);\n      });\n    }\n  }\n\n  // reset node level\n  resetNodeLevel(node: NzTreeNode): void {\n    const parentNode = node.getParentNode();\n    if (parentNode) {\n      node.level = parentNode.level + 1;\n    } else {\n      node.level = 0;\n    }\n    for (const child of node.children) {\n      this.resetNodeLevel(child);\n    }\n  }\n\n  calcDropPosition(event: DragEvent): number {\n    const { clientY } = event;\n    // to fix firefox undefined\n    const { top, bottom, height } = (event.target as Element).getBoundingClientRect();\n    const des = Math.max(height * this.DRAG_SIDE_RANGE, this.DRAG_MIN_GAP);\n\n    if (clientY <= top + des) {\n      return -1;\n    } else if (clientY >= bottom - des) {\n      return 1;\n    }\n\n    return 0;\n  }\n\n  /**\n   * drop\n   * 0: inner -1: pre 1: next\n   */\n  dropAndApply(targetNode: NzTreeNode, dragPos: number = -1): void {\n    if (!targetNode || dragPos > 1) {\n      return;\n    }\n    const treeService = targetNode.treeService;\n    const targetParent = targetNode.getParentNode();\n    const isSelectedRootNode = this.selectedNode.getParentNode();\n    // remove the dragNode\n    if (isSelectedRootNode) {\n      isSelectedRootNode.children = isSelectedRootNode.children.filter(n => n.key !== this.selectedNode.key);\n    } else {\n      this.rootNodes = this.rootNodes.filter(n => n.key !== this.selectedNode.key);\n    }\n    switch (dragPos) {\n      case 0:\n        targetNode.addChildren([this.selectedNode]);\n        this.resetNodeLevel(targetNode);\n        break;\n      case -1:\n      case 1:\n        const tIndex = dragPos === 1 ? 1 : 0;\n        if (targetParent) {\n          targetParent.addChildren([this.selectedNode], targetParent.children.indexOf(targetNode) + tIndex);\n          const parentNode = this.selectedNode.getParentNode();\n          if (parentNode) {\n            this.resetNodeLevel(parentNode);\n          }\n        } else {\n          const targetIndex = this.rootNodes.indexOf(targetNode) + tIndex;\n          // Insert root node.\n          this.rootNodes.splice(targetIndex, 0, this.selectedNode);\n          this.rootNodes[targetIndex].parentNode = null;\n          this.resetNodeLevel(this.rootNodes[targetIndex]);\n        }\n        break;\n    }\n    // flush all nodes\n    this.rootNodes.forEach(child => {\n      if (!child.treeService) {\n        child.service = treeService;\n      }\n      this.refreshDragNode(child);\n    });\n  }\n\n  /**\n   * emit Structure\n   * eventName\n   * node\n   * event: MouseEvent / DragEvent\n   * dragNode\n   */\n  formatEvent(eventName: string, node: NzTreeNode | null, event: MouseEvent | DragEvent | null): NzFormatEmitEvent {\n    const emitStructure: NzFormatEmitEvent = {\n      eventName: eventName,\n      node: node,\n      event: event\n    };\n    switch (eventName) {\n      case 'dragstart':\n      case 'dragenter':\n      case 'dragover':\n      case 'dragleave':\n      case 'drop':\n      case 'dragend':\n        Object.assign(emitStructure, { dragNode: this.getSelectedNode() });\n        break;\n      case 'click':\n      case 'dblclick':\n        Object.assign(emitStructure, { selectedKeys: this.selectedNodeList });\n        Object.assign(emitStructure, { nodes: this.selectedNodeList });\n        Object.assign(emitStructure, { keys: this.selectedNodeList.map(n => n.key) });\n        break;\n      case 'check':\n        const checkedNodeList = this.getCheckedNodeList();\n        Object.assign(emitStructure, { checkedKeys: checkedNodeList });\n        Object.assign(emitStructure, { nodes: checkedNodeList });\n        Object.assign(emitStructure, { keys: checkedNodeList.map(n => n.key) });\n        break;\n      case 'search':\n        Object.assign(emitStructure, { matchedKeys: this.getMatchedNodeList() });\n        Object.assign(emitStructure, { nodes: this.getMatchedNodeList() });\n        Object.assign(emitStructure, { keys: this.getMatchedNodeList().map(n => n.key) });\n        break;\n      case 'expand':\n        Object.assign(emitStructure, { nodes: this.expandedNodeList });\n        Object.assign(emitStructure, { keys: this.expandedNodeList.map(n => n.key) });\n        break;\n    }\n    return emitStructure;\n  }\n\n  /**\n   * New functions for flatten nodes\n   */\n\n  getIndexOfArray(list: NzTreeNode[], key: string): number {\n    return list.findIndex(v => v.key === key);\n  }\n\n  /**\n   * Render by nzCheckedKeys\n   * When keys equals null, just render with checkStrictly\n   * @param keys\n   * @param checkStrictly\n   */\n  conductCheck(keys: NzTreeNodeKey[] | null, checkStrictly: boolean): void {\n    this.checkedNodeList = [];\n    this.halfCheckedNodeList = [];\n    const calc = (nodes: NzTreeNode[]) => {\n      nodes.forEach(node => {\n        if (keys === null) {\n          // render tree if no default checked keys found\n          node.isChecked = !!node.origin.checked;\n        } else {\n          if (isInArray(node.key, keys || [])) {\n            node.isChecked = true;\n            node.isHalfChecked = false;\n          } else {\n            node.isChecked = false;\n            node.isHalfChecked = false;\n          }\n        }\n        if (node.children.length > 0) {\n          calc(node.children);\n        }\n      });\n    };\n    calc(this.rootNodes);\n    this.refreshCheckState(checkStrictly);\n  }\n\n  conductExpandedKeys(keys: NzTreeNodeKey[] | true = []): void {\n    const expandedKeySet = new Set(keys === true ? [] : keys);\n    this.expandedNodeList = [];\n    const calc = (nodes: NzTreeNode[]) => {\n      nodes.forEach(node => {\n        node.setExpanded(keys === true || expandedKeySet.has(node.key) || node.isExpanded === true);\n        if (node.isExpanded) {\n          this.setExpandedNodeList(node);\n        }\n        if (node.children.length > 0) {\n          calc(node.children);\n        }\n      });\n    };\n    calc(this.rootNodes);\n  }\n\n  conductSelectedKeys(keys: NzTreeNodeKey[], isMulti: boolean): void {\n    this.selectedNodeList.forEach(node => (node.isSelected = false));\n    this.selectedNodeList = [];\n    const calc = (nodes: NzTreeNode[]): boolean => {\n      return nodes.every(node => {\n        if (isInArray(node.key, keys)) {\n          node.isSelected = true;\n          this.setSelectedNodeList(node);\n          if (!isMulti) {\n            // if not support multi select\n            return false;\n          }\n        } else {\n          node.isSelected = false;\n        }\n        if (node.children.length > 0) {\n          // Recursion\n          return calc(node.children);\n        }\n        return true;\n      });\n    };\n    calc(this.rootNodes);\n  }\n\n  /**\n   * Expand parent nodes by child node\n   * @param node\n   */\n  expandNodeAllParentBySearch(node: NzTreeNode): void {\n    const calc = (n: NzTreeNode | null): void => {\n      if (n) {\n        n.canHide = false;\n        n.setExpanded(true);\n        this.setExpandedNodeList(n);\n        if (n.getParentNode()) {\n          return calc(n.getParentNode());\n        }\n      }\n    };\n    calc(node.getParentNode());\n  }\n}\n","/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport { InjectionToken } from '@angular/core';\n\nimport { NzTreeBaseService } from './nz-tree-base.service';\n\nexport const NzTreeHigherOrderServiceToken = new InjectionToken<NzTreeBaseService>('NzTreeHigherOrder');\n","/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport { NzSafeAny } from 'ng-zorro-antd/core/types';\nimport { NzTreeNode } from './nz-tree-base-node';\nimport { NzTreeBaseService } from './nz-tree-base.service';\n\nexport class NzTreeBase {\n  constructor(public nzTreeService: NzTreeBaseService) {}\n\n  /**\n   * Coerces a value({@link any[]}) to a TreeNodes({@link NzTreeNode[]})\n   */\n  coerceTreeNodes(value: NzSafeAny[]): NzTreeNode[] {\n    let nodes: NzTreeNode[] = [];\n    if (!this.nzTreeService.isArrayOfNzTreeNode(value)) {\n      // has not been new NzTreeNode\n      nodes = value.map(item => new NzTreeNode(item, null, this.nzTreeService));\n    } else {\n      nodes = value.map((item: NzTreeNode) => {\n        item.service = this.nzTreeService;\n        return item;\n      });\n    }\n    return nodes;\n  }\n\n  /**\n   * Get all nodes({@link NzTreeNode})\n   */\n  getTreeNodes(): NzTreeNode[] {\n    return this.nzTreeService.rootNodes;\n  }\n\n  /**\n   * Get {@link NzTreeNode} with key\n   */\n  getTreeNodeByKey(key: string): NzTreeNode | null {\n    // flat tree nodes\n    const nodes: NzTreeNode[] = [];\n    const getNode = (node: NzTreeNode): void => {\n      nodes.push(node);\n      node.getChildren().forEach(n => {\n        getNode(n);\n      });\n    };\n    this.getTreeNodes().forEach(n => {\n      getNode(n);\n    });\n    return nodes.find(n => n.key === key) || null;\n  }\n\n  /**\n   * Get checked nodes(merged)\n   */\n  getCheckedNodeList(): NzTreeNode[] {\n    return this.nzTreeService.getCheckedNodeList();\n  }\n\n  /**\n   * Get selected nodes\n   */\n  getSelectedNodeList(): NzTreeNode[] {\n    return this.nzTreeService.getSelectedNodeList();\n  }\n\n  /**\n   * Get half checked nodes\n   */\n  getHalfCheckedNodeList(): NzTreeNode[] {\n    return this.nzTreeService.getHalfCheckedNodeList();\n  }\n\n  /**\n   * Get expanded nodes\n   */\n  getExpandedNodeList(): NzTreeNode[] {\n    return this.nzTreeService.getExpandedNodeList();\n  }\n\n  /**\n   * Get matched nodes(if nzSearchValue is not null)\n   */\n  getMatchedNodeList(): NzTreeNode[] {\n    return this.nzTreeService.getMatchedNodeList();\n  }\n}\n"]}