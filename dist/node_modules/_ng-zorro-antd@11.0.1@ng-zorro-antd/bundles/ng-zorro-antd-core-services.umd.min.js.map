{"version":3,"sources":["../../components/core/services/resize.ts","../../components/core/services/singleton.ts","../../components/core/services/drag.ts","../../components/core/services/scroll.ts","../../components/core/services/breakpoint.ts"],"names":["NOOP","NzResizeService","ngZone","rendererFactory2","_this","this","resizeSource$","Subject","listeners","disposeHandle","handler","run","next","renderer","createRenderer","prototype","subscribe","registerListener","pipe","auditTime","finalize","unregisterListener","unsubscribe","runOutsideAngular","listen","Injectable","args","providedIn","NgZone","RendererFactory2","testSingleRegistry","Map","NzSingletonService","_singletonRegistry","Object","defineProperty","environment","isTestMode","registerSingletonWithKey","key","target","alreadyHave","singletonRegistry","has","item","get","withNewTarget","set","getSingletonWithKey","NzDragService","draggingThreshold","currentDraggingSequence","currentStartingPoint","handleRegistry","Set","requestDraggingSequence","event","size","registerDraggingHandler","isTouchEvent","complete","e","getEventPosition","x","pageX","y","pageY","getPagePosition","map","filter","Math","abs","teardownDraggingSequence","isTouch","add","teardown","touches","changedTouches","easeInOutCubic","t","b","c","d","cc","tt","NzBreakpointEnum","NzScrollService","doc","setScrollTop","el","topValue","window","body","scrollTop","documentElement","getOffset","ret","top","left","getClientRects","length","rect","getBoundingClientRect","width","height","ownerDocument","clientTop","clientLeft","getScroll","method","result","isWindow","Document","obj","scrollTo","containerEl","options","startTime","Date","now","easing","callback","_a","duration","frameFunc","time","nextScrollTop","pageXOffset","HTMLDocument","constructor","name","reqAnimFrame","Inject","DOCUMENT","gridResponsiveMap","xs","sm","md","lg","xl","xxl","NzBreakpointService","resizeService","mediaMatcher","breakpointMap","fullMap","matchMedia","startWith","distinctUntilChanged","bp","breakpointBooleanMap","keys","breakpoint","castBP","matched","matches","MediaMatcher"],"mappings":"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","sourcesContent":["/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport { Injectable, NgZone, Renderer2, RendererFactory2 } from '@angular/core';\nimport { Observable, Subject } from 'rxjs';\nimport { auditTime, finalize } from 'rxjs/operators';\n\nconst NOOP = (): void => {};\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class NzResizeService {\n  private readonly resizeSource$ = new Subject<void>();\n\n  private listeners = 0;\n\n  private renderer: Renderer2;\n\n  private disposeHandle = NOOP;\n\n  private handler = (): void => {\n    this.ngZone.run(() => {\n      this.resizeSource$.next();\n    });\n  };\n\n  constructor(private ngZone: NgZone, private rendererFactory2: RendererFactory2) {\n    this.renderer = this.rendererFactory2.createRenderer(null, null);\n  }\n\n  subscribe(): Observable<void> {\n    this.registerListener();\n\n    return this.resizeSource$.pipe(\n      auditTime(16),\n      finalize(() => this.unregisterListener())\n    );\n  }\n\n  unsubscribe(): void {\n    this.unregisterListener();\n  }\n\n  private registerListener(): void {\n    if (this.listeners === 0) {\n      this.ngZone.runOutsideAngular(() => {\n        this.disposeHandle = this.renderer.listen('window', 'resize', this.handler);\n      });\n    }\n\n    this.listeners += 1;\n  }\n\n  private unregisterListener(): void {\n    this.listeners -= 1;\n\n    if (this.listeners === 0) {\n      this.disposeHandle();\n      this.disposeHandle = NOOP;\n    }\n  }\n}\n","/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport { Injectable } from '@angular/core';\n\nimport { environment } from 'ng-zorro-antd/core/environments';\nimport { NzSafeAny } from 'ng-zorro-antd/core/types';\n\ninterface SingletonRegistryItem {\n  target: NzSafeAny;\n}\n\n/**\n * When running in test, singletons should not be destroyed. So we keep references of singletons\n * in this global variable.\n */\nconst testSingleRegistry = new Map<string, SingletonRegistryItem>();\n\n/**\n * Some singletons should have life cycle that is same to Angular's. This service make sure that\n * those singletons get destroyed in HMR.\n */\n@Injectable({\n  providedIn: 'root'\n})\nexport class NzSingletonService {\n  private get singletonRegistry(): Map<string, SingletonRegistryItem> {\n    return environment.isTestMode ? testSingleRegistry : this._singletonRegistry;\n  }\n\n  /**\n   * This registry is used to register singleton in dev mode.\n   * So that singletons get destroyed when hot module reload happens.\n   *\n   * This works in prod mode too but with no specific effect.\n   */\n  private _singletonRegistry = new Map<string, SingletonRegistryItem>();\n\n  registerSingletonWithKey(key: string, target: NzSafeAny): void {\n    const alreadyHave = this.singletonRegistry.has(key);\n    const item: SingletonRegistryItem = alreadyHave ? this.singletonRegistry.get(key)! : this.withNewTarget(target);\n\n    if (!alreadyHave) {\n      this.singletonRegistry.set(key, item);\n    }\n  }\n\n  getSingletonWithKey<T>(key: string): T | null {\n    return this.singletonRegistry.has(key) ? (this.singletonRegistry.get(key)!.target as T) : null;\n  }\n\n  private withNewTarget(target: NzSafeAny): SingletonRegistryItem {\n    return {\n      target\n    };\n  }\n}\n","/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport { Injectable, Renderer2, RendererFactory2 } from '@angular/core';\nimport { Observable, Subject } from 'rxjs';\nimport { filter, finalize, map } from 'rxjs/operators';\n\nimport { getEventPosition, isTouchEvent } from 'ng-zorro-antd/core/util';\n\ninterface Point {\n  x: number;\n  y: number;\n}\n\ntype Delta = Point;\n\ninterface HandlerItem {\n  handler?(e: Event): void;\n\n  teardown(): void;\n}\n\nfunction getPagePosition(event: MouseEvent | TouchEvent): Point {\n  const e = getEventPosition(event);\n  return {\n    x: e.pageX,\n    y: e.pageY\n  };\n}\n\n/**\n * This module provide a global dragging service to other components.\n */\n@Injectable({\n  providedIn: 'root'\n})\nexport class NzDragService {\n  private draggingThreshold = 5;\n  private currentDraggingSequence: Subject<MouseEvent | Touch> | null = null;\n  private currentStartingPoint: Point | null = null;\n  private handleRegistry = new Set<HandlerItem>();\n  private renderer: Renderer2;\n\n  constructor(rendererFactory2: RendererFactory2) {\n    this.renderer = rendererFactory2.createRenderer(null, null);\n  }\n\n  requestDraggingSequence(event: MouseEvent | TouchEvent): Observable<Delta> {\n    if (!this.handleRegistry.size) {\n      this.registerDraggingHandler(isTouchEvent(event));\n    }\n\n    // Complete last dragging sequence if a new target is dragged.\n    if (this.currentDraggingSequence) {\n      this.currentDraggingSequence.complete();\n    }\n\n    this.currentStartingPoint = getPagePosition(event);\n    this.currentDraggingSequence = new Subject<MouseEvent | Touch>();\n\n    return this.currentDraggingSequence.pipe(\n      map((e: MouseEvent | Touch) => {\n        return {\n          x: e.pageX - this.currentStartingPoint!.x,\n          y: e.pageY - this.currentStartingPoint!.y\n        };\n      }),\n      filter((e: Delta) => Math.abs(e.x) > this.draggingThreshold || Math.abs(e.y) > this.draggingThreshold),\n      finalize(() => this.teardownDraggingSequence())\n    );\n  }\n\n  private registerDraggingHandler(isTouch: boolean): void {\n    if (isTouch) {\n      this.handleRegistry.add({\n        teardown: this.renderer.listen('document', 'touchmove', (e: TouchEvent) => {\n          if (this.currentDraggingSequence) {\n            this.currentDraggingSequence.next(e.touches[0] || e.changedTouches[0]);\n          }\n        })\n      });\n      this.handleRegistry.add({\n        teardown: this.renderer.listen('document', 'touchend', () => {\n          if (this.currentDraggingSequence) {\n            this.currentDraggingSequence.complete();\n          }\n        })\n      });\n    } else {\n      this.handleRegistry.add({\n        teardown: this.renderer.listen('document', 'mousemove', e => {\n          if (this.currentDraggingSequence) {\n            this.currentDraggingSequence.next(e);\n          }\n        })\n      });\n      this.handleRegistry.add({\n        teardown: this.renderer.listen('document', 'mouseup', () => {\n          if (this.currentDraggingSequence) {\n            this.currentDraggingSequence.complete();\n          }\n        })\n      });\n    }\n  }\n\n  private teardownDraggingSequence(): void {\n    this.currentDraggingSequence = null;\n  }\n}\n","/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport { DOCUMENT } from '@angular/common';\nimport { Inject, Injectable } from '@angular/core';\nimport { reqAnimFrame } from 'ng-zorro-antd/core/polyfill';\nimport { NzSafeAny } from 'ng-zorro-antd/core/types';\n\nexport type EasyingFn = (t: number, b: number, c: number, d: number) => number;\n\nfunction easeInOutCubic(t: number, b: number, c: number, d: number): number {\n  const cc = c - b;\n  let tt = t / (d / 2);\n  if (tt < 1) {\n    return (cc / 2) * tt * tt * tt + b;\n  } else {\n    return (cc / 2) * ((tt -= 2) * tt * tt + 2) + b;\n  }\n}\n\nexport interface NzScrollToOptions {\n  /** Scroll container, default as window */\n  easing?: EasyingFn;\n  /** Scroll end callback */\n  callback?(): void;\n  /** Animation duration, default as 450 */\n  duration?: number;\n}\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class NzScrollService {\n  private doc: Document;\n\n  constructor(@Inject(DOCUMENT) doc: NzSafeAny) {\n    this.doc = doc;\n  }\n\n  /** Set the position of the scroll bar of `el`. */\n  setScrollTop(el: Element | Window, topValue: number = 0): void {\n    if (el === window) {\n      this.doc.body.scrollTop = topValue;\n      this.doc.documentElement!.scrollTop = topValue;\n    } else {\n      (el as Element).scrollTop = topValue;\n    }\n  }\n\n  /** Get position of `el` against window. */\n  getOffset(el: Element): { top: number; left: number } {\n    const ret = {\n      top: 0,\n      left: 0\n    };\n    if (!el || !el.getClientRects().length) {\n      return ret;\n    }\n\n    const rect = el.getBoundingClientRect();\n    if (rect.width || rect.height) {\n      const doc = el.ownerDocument!.documentElement;\n      ret.top = rect.top - doc!.clientTop;\n      ret.left = rect.left - doc!.clientLeft;\n    } else {\n      ret.top = rect.top;\n      ret.left = rect.left;\n    }\n\n    return ret;\n  }\n\n  /** Get the position of the scoll bar of `el`. */\n  // TODO: remove '| Window' as the fallback already happens here\n  getScroll(target?: Element | HTMLElement | Window | Document | null, top: boolean = true): number {\n    if (typeof window === 'undefined') {\n      return 0;\n    }\n    const method = top ? 'scrollTop' : 'scrollLeft';\n    let result = 0;\n    if (this.isWindow(target)) {\n      result = (target as Window)[top ? 'pageYOffset' : 'pageXOffset'];\n    } else if (target instanceof Document) {\n      result = target.documentElement[method];\n    } else if (target) {\n      result = (target as HTMLElement)[method];\n    }\n    if (target && !this.isWindow(target) && typeof result !== 'number') {\n      result = ((target as HTMLElement).ownerDocument || (target as Document)).documentElement[method];\n    }\n    return result;\n  }\n\n  isWindow(obj: NzSafeAny): boolean {\n    return obj !== null && obj !== undefined && obj === obj.window;\n  }\n\n  /**\n   * Scroll `el` to some position with animation.\n   *\n   * @param containerEl container, `window` by default\n   * @param y Scroll to `top`, 0 by default\n   */\n  scrollTo(containerEl?: Element | HTMLElement | Window | Document | null, y: number = 0, options: NzScrollToOptions = {}): void {\n    const target = containerEl ? containerEl : window;\n    const scrollTop = this.getScroll(target);\n    const startTime = Date.now();\n    const { easing, callback, duration = 450 } = options;\n    const frameFunc = () => {\n      const timestamp = Date.now();\n      const time = timestamp - startTime;\n      const nextScrollTop = (easing || easeInOutCubic)(time > duration ? duration : time, scrollTop, y, duration);\n      if (this.isWindow(target)) {\n        (target as Window).scrollTo(window.pageXOffset, nextScrollTop);\n      } else if (target instanceof HTMLDocument || target.constructor.name === 'HTMLDocument') {\n        (target as HTMLDocument).documentElement.scrollTop = nextScrollTop;\n      } else {\n        (target as HTMLElement).scrollTop = nextScrollTop;\n      }\n      if (time < duration) {\n        reqAnimFrame(frameFunc);\n      } else if (typeof callback === 'function') {\n        callback();\n      }\n    };\n    reqAnimFrame(frameFunc);\n  }\n}\n","/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport { MediaMatcher } from '@angular/cdk/layout';\nimport { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { distinctUntilChanged, map, startWith } from 'rxjs/operators';\n\nimport { NzResizeService } from './resize';\n\nexport enum NzBreakpointEnum {\n  xxl = 'xxl',\n  xl = 'xl',\n  lg = 'lg',\n  md = 'md',\n  sm = 'sm',\n  xs = 'xs'\n}\n\nexport type BreakpointMap = { [key in NzBreakpointEnum]: string };\nexport type BreakpointBooleanMap = { [key in NzBreakpointEnum]: boolean };\nexport type NzBreakpointKey = keyof typeof NzBreakpointEnum;\n\nexport const gridResponsiveMap: BreakpointMap = {\n  xs: '(max-width: 575px)',\n  sm: '(min-width: 576px)',\n  md: '(min-width: 768px)',\n  lg: '(min-width: 992px)',\n  xl: '(min-width: 1200px)',\n  xxl: '(min-width: 1600px)'\n};\n\nexport const siderResponsiveMap: BreakpointMap = {\n  xs: '(max-width: 479.98px)',\n  sm: '(max-width: 575.98px)',\n  md: '(max-width: 767.98px)',\n  lg: '(max-width: 991.98px)',\n  xl: '(max-width: 1199.98px)',\n  xxl: '(max-width: 1599.98px)'\n};\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class NzBreakpointService {\n  constructor(private resizeService: NzResizeService, private mediaMatcher: MediaMatcher) {\n    this.resizeService.subscribe().subscribe(() => {});\n  }\n\n  subscribe(breakpointMap: BreakpointMap): Observable<NzBreakpointEnum>;\n  subscribe(breakpointMap: BreakpointMap, fullMap: true): Observable<BreakpointBooleanMap>;\n  subscribe(breakpointMap: BreakpointMap, fullMap?: true): Observable<NzBreakpointEnum | BreakpointBooleanMap> {\n    if (fullMap) {\n      const get = () => this.matchMedia(breakpointMap, true);\n      return this.resizeService.subscribe().pipe(\n        map(get),\n        startWith(get()),\n        distinctUntilChanged((x: [NzBreakpointEnum, BreakpointBooleanMap], y: [NzBreakpointEnum, BreakpointBooleanMap]) => x[0] === y[0]),\n        map(x => x[1])\n      );\n    } else {\n      const get = () => this.matchMedia(breakpointMap);\n      return this.resizeService.subscribe().pipe(map(get), startWith(get()), distinctUntilChanged());\n    }\n  }\n\n  private matchMedia(breakpointMap: BreakpointMap): NzBreakpointEnum;\n  private matchMedia(breakpointMap: BreakpointMap, fullMap: true): [NzBreakpointEnum, BreakpointBooleanMap];\n  private matchMedia(breakpointMap: BreakpointMap, fullMap?: true): NzBreakpointEnum | [NzBreakpointEnum, BreakpointBooleanMap] {\n    let bp = NzBreakpointEnum.md;\n\n    const breakpointBooleanMap: Partial<BreakpointBooleanMap> = {};\n\n    Object.keys(breakpointMap).map(breakpoint => {\n      const castBP = breakpoint as NzBreakpointEnum;\n      const matched = this.mediaMatcher.matchMedia(gridResponsiveMap[castBP]).matches;\n\n      breakpointBooleanMap[breakpoint as NzBreakpointEnum] = matched;\n\n      if (matched) {\n        bp = castBP;\n      }\n    });\n\n    if (fullMap) {\n      return [bp, breakpointBooleanMap as BreakpointBooleanMap];\n    } else {\n      return bp;\n    }\n  }\n}\n"]}